## 类加载生命周期

加载
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

ps: 开放性：加载阶段并没有指明二进制字节流要从哪一个Class文件中获取，准备地说是根本没有指明要从哪里获取，怎么获取。

验证

1. 文件格式验证  
验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理

2. 元数据验证  
对字节码描述的信息进行语义分析，以保证其其描述的信息符合Java语言规范的要求

3. 字节码验证  
通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段
将对类的方法进行检验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件

4. 符号引用验证
可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验

准备

正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念
需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对
象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。

解析

1. 类或接口的解析

2. 字段解析

3. 类方法解析

3. 接口方法解析

初始化

使用

卸载


## 双亲委派模型

工作过程： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是
把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求
（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处： 例如类 java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，
最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类
加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类自行去加载的
话，如果用户自己编写了一个名称为java.lang.Object的类，并放在程序的ClassPath中，那
系统中将会出现多个不用的Object类，Java类型体系中最基础的行为也就无法保证，应用程序
也将会变得一片混乱。



